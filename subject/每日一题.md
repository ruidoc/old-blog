## 每日一题

每天一道面试题

### 1. 模拟一个 map 方法

```js
Array.prototype.mymap = function (itemfn: Function) {
    var new_arr = []
    if (this instanceof Array && this.length>0) {
        for (let i = 0; i < this.length; i++) {
            let itemres = itemfn(this[i], i)
            if(itemres) new_arr.push(itemres)
        }
    }
    return new_arr;
}
```

### 2. 闭包计数器

```js
// 题目要求：使用闭包实现一个计数器 add
// 预期效果：
add();   // 第一次运行打印：1
add();   // 第二次运行打印：2
```

实现方法

```js
var add = (function() {
    var n = 1
    return function() {
        console.log(n++);
    }
})()

add() // 1
add() // 2
```

### 3. 函数柯里化（Currying）

```js
// 题目要求：实现一个函数的柯里化
// 预期效果：
sum(1);        // 打印：1
sum(1)(2);     // 打印：3
sum(1)(2)(3);  // 打印：6
```

首先：累计相加，至少有两种方法：

1. 两两相加得出值，再加下一个
2. 保存为数组，最后统一相加

其次，要实现函数递归调用，有个标准思路：

**在函数内返回一个新函数，在新函数内返回原函数的调用** 。

```js
function sum(...arr) {
    let fn = (...arr2)=> {
        return sum(...arr.concat(arr2));
    }
    fn.count = ()=> {
        console.log(arr.reduce((n1,n2)=> n1+n2))
    }
    return fn;
}

sum(1)(2)(3)(4).count()
```

### 4. 实现 sleep 函数

首先，promise 实现方法：

```js
function sleep(ms) {
    return new Promise(resolve=> setTimeout(resolve, ms))
}
```

async/await 实现方法：

```js
async function sleep(ms) {
    await new Promise(resolve=> setTimeout(resolve, ms))
}
```

函数用法：

```js
(async function() {
  console.log('Hello')
  await sleep(1000)
  console.log('world!')
})()
```

### 5. 防抖

```js
// 题目要求：实现一个函数debounce()
// 预期效果：
// 500ms后输出：hello
// 1500ms后输出：world
```

```js
function debounce(fn, delay) {
    var timer = null
    return function(...args) {
        if(timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => fn(...args), delay);
    }
}
var handle = debounce(str=> {
    console.log(str)
}, 500)
var handle2 = debounce(str=> {
    console.log(str)
}, 1500)

handle('hello')
handle2('word')

```

### 6. 实现一个Range()

```js
// 题目要求：实现一个 Range(from, to, step)
// 预期效果：
Range(1, 10, 3);      // 输出：[1,4,7,10]
Range("A", "F", 2);   // 输出：["A","C","E"]
```

实现方法：

```js
var range = (from, to, step)=> {
    var arr = []
    if(typeof from == 'number' && typeof to == 'number' ){
        for(let i = min; i<=max; i=i+step){
            arr.push(i)
        }
    }
    if(typeof from == 'string' && typeof to == 'string' ){
        var minIndex = from.charCodeAt();
        var maxIndex = to.charCodeAt();
        for (let i = minIndex; i <= maxIndex; i=i+step) {
            arr.push(String.fromCharCode(i))
        }
    }
}
```

`charCodeAt()` 方法返回字母的 Unicode 编码，连续字母的 Unicode 编码之差为 **1**。如：

- A 的编码为 65
- B 的编码为 66
- C 的编码为 67

`String.fromCharCode` 方法根据 Unicode 编码返回字母字符串。
