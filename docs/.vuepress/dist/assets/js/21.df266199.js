(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{376:function(t,_,v){"use strict";v.r(_);var s=v(44),a=Object(s.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"http-大揭秘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-大揭秘"}},[t._v("#")]),t._v(" HTTP 大揭秘")]),t._v(" "),v("p",[t._v("相比于 TCP，HTTP 在日常开发中更需要我们扎实的掌握。")]),t._v(" "),v("p",[t._v("需要着重掌握三个方面的考点：")]),t._v(" "),v("ul",[v("li",[t._v("HTTP 请求方法；")]),t._v(" "),v("li",[t._v("HTTP 状态码；")]),t._v(" "),v("li",[t._v("对"),v("strong",[t._v("无状态")]),t._v("的理解。")])]),t._v(" "),v("p",[t._v("除此之外，还有 HTTP 不同阶段的特性。")]),t._v(" "),v("h3",{attrs:{id:"http-通用考点梳理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-通用考点梳理"}},[t._v("#")]),t._v(" HTTP 通用考点梳理")]),t._v(" "),v("h4",{attrs:{id:"http-状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),v("p",[t._v("响应分为五类：")]),t._v(" "),v("ul",[v("li",[t._v("信息响应(100–199)，")]),t._v(" "),v("li",[t._v("成功响应(200–299)，")]),t._v(" "),v("li",[t._v("重定向(300–399)，")]),t._v(" "),v("li",[t._v("客户端错误(400–499)，")]),t._v(" "),v("li",[t._v("服务器错误 (500–599)")])]),t._v(" "),v("p",[t._v("常用响应状态如下：")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("1xx")]),t._v("：需要客户端继续请求。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("2xx")]),t._v("：成功接收请求、且已处理完毕。\n-- 200：OK，表示正常响应\n-- 201：Created，请求成功，并创建了一个新的资源\n-- 202：Accepted，请求成功，服务器正在处理（异步任务）\n-- 206：Partical Content，处理部分 get 请求，断点续传和分块下载时的状态。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("3xx")]),t._v("：重定向。\n-- 301：永久性重定向，表示资源已被分配了新的 URL\n-- 302：临时性重定向，资源临时被分配了新的 URL\n-- 304：返回缓存的资源")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("4xx")]),t._v("：客户端错误\n-- 400：Bad Request，常指参数错误\n-- 401：Unauthorized，身份验证失败，token 失效\n-- 403：Forbidden，服务器拒绝（多半是没权限）\n-- 404：Not Found，资源不存在\n-- 405：Method Not Allowed，请求方法错误\n-- 408：Request Timeout：请求超时\n-- 413：Payload Too Large：请求资源太大，拒绝处理（文件上传）")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("5xx")]),t._v("：服务器错误\n-- 500：服务器内部错误\n-- 502：Bad Gateway，网关错误\n-- 504：Gateway Timeout，网关超时")])])]),t._v(" "),v("blockquote",[v("p",[t._v("网关：转发其他服务器通信数据的服务器")])]),t._v(" "),v("h4",{attrs:{id:"http-请求方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-请求方法"}},[t._v("#")]),t._v(" HTTP 请求方法")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("GET")]),t._v("：数据读取，参数为 query 形式")]),t._v(" "),v("li",[v("strong",[t._v("POST")]),t._v("：创建/修改资源，参数为 body 形式")]),t._v(" "),v("li",[v("strong",[t._v("HEAD")]),t._v("：只获取响应头信息")]),t._v(" "),v("li",[v("strong",[t._v("PUT")]),t._v("：修改某个具体资源")]),t._v(" "),v("li",[v("strong",[t._v("DELETE")]),t._v("：删除指定的资源")]),t._v(" "),v("li",[v("strong",[t._v("OPTIONS")]),t._v("：获取服务器支持的通信选项")])]),t._v(" "),v("h4",{attrs:{id:"高频考点-对-无状态-的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高频考点-对-无状态-的理解"}},[t._v("#")]),t._v(" 高频考点——对“无状态”的理解")]),t._v(" "),v("p",[t._v("HTTP 协议是无状态的。")]),t._v(" "),v("p",[t._v("“无状态”可以理解为”无记忆“。即前一个 A 请求和后一个 B 请求完全无关联，互相独立。")]),t._v(" "),v("p",[t._v("如果想维护状态信息怎么办？两个思路："),v("strong",[t._v("cookie")]),t._v(" 和 "),v("strong",[t._v("session")]),t._v("。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("cookie")]),t._v("：存储在浏览器的小段文本，请求时会发到服务器上。")]),t._v(" "),v("li",[v("strong",[t._v("session")]),t._v("：存储在服务器的数据。服务器创建一个 session 时，会将 session-id 写入 cookie 中。后面再从请求的 cookie 中解析出 session-id，进而找到这个 session。")])]),t._v(" "),v("h5",{attrs:{id:"cookie"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" cookie")]),t._v(" "),v("p",[t._v("一系列的键值对。形式为 name=value，中间用分号和空格分割。")]),t._v(" "),v("div",{staticClass:"language-sh extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[t._v("Cookie: "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("PHPSESSID")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("298zf09hf012fh2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("csrftoken")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("u32t4o3tb3gg43"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("h3",{attrs:{id:"http-的发展史"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-的发展史"}},[t._v("#")]),t._v(" HTTP 的发展史")]),t._v(" "),v("p",[t._v("http 不是一成不变的，它一直在发展进化。截止到 2.0 过程如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:"/assets/8712AA1C-DAAE-4E43-AB90-26ECF3A09908.png",alt:"8712AA1C-DAAE-4E43-AB90-26ECF3A09908"}})]),t._v(" "),v("p",[t._v("0.9 版本年代太过久远，这里不讨论。就从 1.0 开始说起：")]),t._v(" "),v("h4",{attrs:{id:"http1-1-解决的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-解决的问题"}},[t._v("#")]),t._v(" HTTP1.1 解决的问题")]),t._v(" "),v("p",[t._v("首先，要知道 HTTP1.0 的痛点：")]),t._v(" "),v("h5",{attrs:{id:"_1-tcp-连接不可复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp-连接不可复用"}},[t._v("#")]),t._v(" 1. TCP 连接不可复用")]),t._v(" "),v("p",[t._v("每通信一次，都需要“三步走” —— TCP 连接、HTTP 通信、断开 TCP 连接：")]),t._v(" "),v("p",[v("img",{attrs:{src:"/assets/2BDFD233-2755-44E8-ACEB-A79E74515E1B.png",alt:"2BDFD233-2755-44E8-ACEB-A79E74515E1B"}})]),t._v(" "),v("p",[t._v("当通信频率非常高时，这样每次三步走会很消耗资源。")]),t._v(" "),v("p",[t._v("HTTP1.1 解决了这个问题，效果如图：")]),t._v(" "),v("p",[v("img",{attrs:{src:"/assets/F238716F-8787-41E9-BF62-CA5BDE61243C.png",alt:"F238716F-8787-41E9-BF62-CA5BDE61243C"}})]),t._v(" "),v("p",[t._v("这样在一个 TCP 连接里可以进行多次 HTTP 通信的机制，就是 —— "),v("strong",[t._v("长连接")]),t._v("。")]),t._v(" "),v("h5",{attrs:{id:"_2-队头阻塞问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-队头阻塞问题"}},[t._v("#")]),t._v(" 2. 队头阻塞问题")]),t._v(" "),v("p",[t._v("HTTP/1.0 中，请求是串行的。即一个个请求必须按顺序处理。")]),t._v(" "),v("p",[t._v("这样的问题是：如果一个请求堵塞，后面的请求会一直等待。")]),t._v(" "),v("p",[t._v("HTTP/1.1 解决方案："),v("strong",[t._v("管线化")]),t._v("。即允许多个 HTTP 请求批量提交到服务器。")]),t._v(" "),v("p",[t._v("不过这个方案并未真正解决问题。因为服务器还是要安顺序响应，也就是说响应仍是串行的，还是会堵塞。")]),t._v(" "),v("h4",{attrs:{id:"http2-0-对性能的改进"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2-0-对性能的改进"}},[t._v("#")]),t._v(" HTTP2.0 对性能的改进")]),t._v(" "),v("p",[t._v("改进性能是 HTTP2.0 的核心目标。看看它作出的努力：")]),t._v(" "),v("h5",{attrs:{id:"_1-二进制分帧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-二进制分帧"}},[t._v("#")]),t._v(" 1. 二进制分帧")]),t._v(" "),v("p",[t._v("HTTP1.x 中，数据直接以文本传递。")]),t._v(" "),v("p",[t._v("HTTP2.0 会将消息划分为"),v("strong",[t._v("消息")]),t._v("和"),v("strong",[t._v("帧")]),t._v("，并用二进制编码，确保高效解析。")]),t._v(" "),v("h5",{attrs:{id:"_2-头部压缩"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-头部压缩"}},[t._v("#")]),t._v(" 2. 头部压缩")]),t._v(" "),v("p",[t._v("HTTP2.0 中，客户端和服务器会分别维护一份相同的头部静态 数据，和一份不同的动态数据。")]),t._v(" "),v("p",[t._v("当发生通信时，不同的请求头会被写入动态数据。后面的请求只携带这份不同的请求头，其他头部信息从静态数据中获取。")]),t._v(" "),v("p",[t._v("相对于 HTTP1.x 中每次都要携带整个头部跑来跑去的笨重操作来说，大大节省了网络开销。")]),t._v(" "),v("h5",{attrs:{id:"_3-服务端推送"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务端推送"}},[t._v("#")]),t._v(" 3. 服务端推送")]),t._v(" "),v("p",[t._v("在 HTTP1.x 中，如果资源 A 依赖 资源 B，那么请求 资源 A 时必须要先请求资源 B。")]),t._v(" "),v("p",[t._v("而 HTTP2.0 中，允许服务器主动向客户端 push 资源。即当客户端忘记请求资源 B 时，服务器可以主动将它推送给客户端。")]),t._v(" "),v("h5",{attrs:{id:"_4-多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-多路复用"}},[t._v("#")]),t._v(" 4. 多路复用")]),t._v(" "),v("p",[t._v("上面说到，HTTP1.1 并未真正解决队头阻塞问题。")]),t._v(" "),v("p",[t._v("到了 HTTP2.0，终于有了解决方案，就是多路复用。")]),t._v(" "),v("p",[v("strong",[t._v("多路复用其实就是进化版的长连接")]),t._v("。")]),t._v(" "),v("p",[t._v("在 HTTP 2.0 多路复用下，请求之前互相独立，完全实现了并行请求，并行响应，彻底解决了队头阻塞问题。")])])}),[],!1,null,null,null);_.default=a.exports}}]);